# アプリケーション監視

- アプリケーションにはもっとも高頻度に変更が加えられる
- アプリケーションのパフォーマンスに対する可視性は高い重要性を持っている

## メトリクスでアプリケーションを計測する

- シンプルなメトリクスを計測する
  - データベースクエリの実行にかかった時間
  - 外部ベンダーのAPIが応答するのにかかった時間
  - 1日に発生したログインの数
- StatsDの話

### 内部ではどのように動いているのか

- StatsDの話
  - メトリクスをStatsDサーバーに送信するときは、UDPを経由している
  - UDPはノンブロッキングなプロトコルなので、パフォーマンスに大きな影響を与えることがない

## ビルドとリリースのパイプラインの監視

- 見落とされがち
- アプリケーションやインフラのメトリクスと一緒に利用するメタ情報が役に立つ
  - デプロイがいつ始まったか
  - デプロイがいつ終わったか
  - どのビルドがデプロイされたか
  - 誰がデプロイを実行したか
- 例：APIエラー率にデプロイイベントを重ねたグラフ
  - 直近のデプロイと、API成功率の変化が関係してそうなことがわかる

## healthエンドポイントパターン

- アプリケーションの健全性を伝えるアプリケーション内のHTTPエンドポイント
- アプリケーションについての基本的な情報を返す
  - デプロイされたバージョン
  - 依存性のステータス
- プル型
  - プッシュ型に比べて、
- ロードバランサーやサービスディスカバリツールによるヘルスチェックに利用できる
- 環境内で何が動いているのかが簡単に判断できるので、デバッグに便利
- アプリケーションが自分自身の健全性を把握できるようになる

## アプリケーションロギング

- アプリケーションからはデータ構造に直接アクセスできるので、構造化ログを送信するのは非常に簡単はなず

### メトリクスにすべきかログにすべきか

- チームにとってメトリクスで考えるほうが楽か、ログで考えるほうが楽か
- ある問題について、メトリクスとログのどちらがより効果的か

### 何のログを取るべきか

- なんでもかんでもログとってたら、パフォーマンス低下の原因になる

### ディスクに書くべきか、ネットワーク越しに送るべきか

- ネットワーク越しに送るの、アプリケーションのトラフィックが増えるにつれてボトルネックになる
- ディスクに書く→定期的に外部に送る、がいいかも

## サーバーレスまたはFunction-as-a-Service

- 呼び出される→ジョブを処理する→停止する、の総実行時間が1秒以下の場合がある
- 伝統的なポーリングモデルは、ポーリング間隔をそこまで短くできない
- StatsDを使おう

## マイクロサービスアークテクチャを監視する

- マイクロサービスにすると、ユーザーのリクエストに対して何が起きているかを把握するのが難しくなる
- 分散トレーシングを使おう
- 仕組みとして導入するのはかなりコストかかるので、覚悟する
